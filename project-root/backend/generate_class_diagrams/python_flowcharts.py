import ast
import pydot
import os
import sys
import logging
import multiprocessing
from typing import Dict, List, Tuple, Union
from datetime import datetime
from reportlab.lib.pagesizes import letter
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib import colors
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image, Table, TableStyle, PageTemplate, Frame, KeepInFrame
from reportlab.platypus import PageBreak
from reportlab.pdfgen.canvas import Canvas

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class FunctionInfo:
    def __init__(self, name: str):
        self.name = name
        self.statements: List[ast.AST] = []
        self.complexity = 0
        self.num_statements = 0
        self.control_structures = {
            'if': 0,
            'for': 0,
            'while': 0,
            'try': 0
        }

class ClassInfo:
    def __init__(self, name: str):
        self.name = name
        self.methods: Dict[str, FunctionInfo] = {}
        self.total_methods = 0
        self.total_complexity = 0

current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(current_dir)
input_dir = os.path.join(project_root, 'testing', 'pythonTesting')


def create_header_footer(canvas, doc):
    """Create a minimalist header and footer with separating lines"""
    canvas.saveState()
    
    # Header positioning
    header_top = doc.pagesize[1] - 40
    
    # Add logo
    logo_path = os.path.join(current_dir, 'logo_with_white_bg.png')
    if os.path.exists(logo_path):
        canvas.drawImage(logo_path, 
                        doc.leftMargin - 20,
                        header_top - 35,
                        width=40, 
                        height=40,
                        preserveAspectRatio=True)
    
    # Add DevCanvas text next to logo
    canvas.setFont('Helvetica-Bold', 14)
    canvas.setFillColor(colors.Color(0.2, 0.2, 0.2))
    canvas.drawString(doc.leftMargin + 30, 
                     header_top - 25,
                     "BITM")
    
    # Add report generation date
    canvas.setFont('Helvetica', 10)
    canvas.setFillColor(colors.Color(0.4, 0.4, 0.4))
    date_str = datetime.now().strftime('%B %d, %Y')
    canvas.drawString(doc.width + doc.leftMargin - 120,
                     header_top - 25,
                     f"Generated: {date_str}")
    
    # Header separation line
    canvas.setStrokeColor(colors.Color(0.8, 0.8, 0.8))
    canvas.line(doc.leftMargin - 30,
                header_top - 45,
                doc.width + doc.leftMargin + 30,
                header_top - 45)
    
    # Footer separation line
    canvas.line(doc.leftMargin - 30,
                doc.bottomMargin - 20,
                doc.width + doc.leftMargin + 30,
                doc.bottomMargin - 20)
    
    # Footer text
    canvas.setFont('Helvetica', 9)
    canvas.setFillColor(colors.Color(0.4, 0.4, 0.4))
    canvas.drawString(doc.leftMargin, 
                     doc.bottomMargin - 35,
                     "Generated by BITM")
    
    # Add page number
    page_num = canvas.getPageNumber()
    canvas.drawRightString(doc.width + doc.leftMargin,
                          doc.bottomMargin - 35,
                          f"Page {page_num}")
    
    canvas.restoreState()

def safe_write_png(graph, filename):
    output_path = os.path.join(current_dir, filename)
    try:
        graph.write_png(output_path)
        logging.info(f"Generated: {output_path}")
    except Exception as e:
        logging.error(f"Error writing {filename}: {str(e)}")

def analyze_complexity(statements: List[ast.AST]) -> Dict:
    complexity = 1  # Base complexity
    control_structures = {
        'if': 0,
        'for': 0,
        'while': 0,
        'try': 0
    }
    
    for stmt in statements:
        if isinstance(stmt, (ast.If, ast.For, ast.While)):
            complexity += 1
        
        if isinstance(stmt, ast.If):
            control_structures['if'] += 1
        elif isinstance(stmt, ast.For):
            control_structures['for'] += 1
        elif isinstance(stmt, ast.While):
            control_structures['while'] += 1
        elif isinstance(stmt, ast.Try):
            control_structures['try'] += 1
    
    return {
        'complexity': complexity,
        'num_statements': len(statements),
        'control_structures': control_structures
    }

def analyze_python_file(file_path: str) -> Dict[str, Union[ClassInfo, FunctionInfo]]:
    elements = {}
    with open(file_path, 'r') as file:
        try:
            tree = ast.parse(file.read(), filename=file_path)
        except SyntaxError as e:
            logging.error(f"Syntax error in {file_path}: {e}")
            return {}

        for node in ast.iter_child_nodes(tree):
            if isinstance(node, ast.ClassDef):
                class_name = node.name
                class_info = ClassInfo(class_name)
                
                for item in node.body:
                    if isinstance(item, ast.FunctionDef):
                        method_info = FunctionInfo(item.name)
                        method_info.statements = item.body
                        
                        analysis = analyze_complexity(item.body)
                        method_info.complexity = analysis['complexity']
                        method_info.num_statements = analysis['num_statements']
                        method_info.control_structures = analysis['control_structures']
                        
                        class_info.methods[item.name] = method_info
                        class_info.total_methods += 1
                        class_info.total_complexity += method_info.complexity
                
                elements[class_name] = class_info
            elif isinstance(node, ast.FunctionDef):
                function_name = node.name
                function_info = FunctionInfo(function_name)
                function_info.statements = node.body
                
                analysis = analyze_complexity(node.body)
                function_info.complexity = analysis['complexity']
                function_info.num_statements = analysis['num_statements']
                function_info.control_structures = analysis['control_structures']
                
                elements[function_name] = function_info

    return elements

def list_python_files(directory: str) -> List[str]:
    python_files = []
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith('.py'):
                python_files.append(os.path.join(root, file))
    return python_files

def analyze_directory(directory: str) -> Dict[str, Union[ClassInfo, FunctionInfo]]:
    all_elements = {}
    file_paths = list_python_files(directory)
    
    with multiprocessing.Pool() as pool:
        results = pool.map(analyze_python_file, file_paths)
        for result in results:
            all_elements.update(result)
    
    return all_elements

def generate_flowchart(func_info: FunctionInfo) -> pydot.Dot:
    graph = pydot.Dot(graph_type='digraph', rankdir='TB', ratio='compress', size='8,8')
    graph.set_node_defaults(shape='rectangle', style='rounded', height='0.4', width='2')

    start = pydot.Node("start", label="Start", shape="ellipse")
    graph.add_node(start)

    end = pydot.Node("end", label="End", shape="ellipse")

    prev_node = start
    for i, stmt in enumerate(func_info.statements):
        if isinstance(stmt, ast.If):
            if_node = pydot.Node(f"if_{i}", label=f"If\n{ast.unparse(stmt.test)}", shape="diamond")
            graph.add_node(if_node)
            graph.add_edge(pydot.Edge(prev_node, if_node))
            
            true_node = pydot.Node(f"true_{i}", label="True")
            false_node = pydot.Node(f"false_{i}", label="False")
            graph.add_node(true_node)
            graph.add_node(false_node)
            
            graph.add_edge(pydot.Edge(if_node, true_node, label="Yes"))
            graph.add_edge(pydot.Edge(if_node, false_node, label="No"))
            
            prev_node = if_node
        elif isinstance(stmt, (ast.For, ast.While)):
            loop_node = pydot.Node(f"loop_{i}", label=f"{type(stmt).__name__} loop", shape="diamond")
            graph.add_node(loop_node)
            graph.add_edge(pydot.Edge(prev_node, loop_node))
            prev_node = loop_node
        else:
            node = pydot.Node(f"stmt_{i}", label=type(stmt).__name__)
            graph.add_node(node)
            graph.add_edge(pydot.Edge(prev_node, node))
            prev_node = node

    graph.add_node(end)
    graph.add_edge(pydot.Edge(prev_node, end))

    return graph

def generate_flowcharts(elements: Dict[str, Union[ClassInfo, FunctionInfo]]) -> Dict[str, Union[Dict[str, pydot.Dot], pydot.Dot]]:
    flowcharts = {}
    for name, element in elements.items():
        if isinstance(element, ClassInfo):
            flowcharts[name] = {}
            for method_name, method_info in element.methods.items():
                flowcharts[name][method_name] = generate_flowchart(method_info)
        elif isinstance(element, FunctionInfo):
            flowcharts[name] = generate_flowchart(element)
    return flowcharts

def generate_pdf(flowcharts: Dict[str, Union[Dict[str, pydot.Dot], pydot.Dot]], 
                elements: Dict[str, Union[ClassInfo, FunctionInfo]], 
                output_path: str):
    doc = SimpleDocTemplate(
        output_path,
        pagesize=letter,
        rightMargin=72,
        leftMargin=72,
        topMargin=110,  # Adjusted for better spacing
        bottomMargin=72
    )
    
    styles = getSampleStyleSheet()
    styles.add(ParagraphStyle(
        name='CustomHeading1',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=20,  # Reduced spacing
        textColor=colors.Color(0.2, 0.2, 0.2)
    ))
    styles.add(ParagraphStyle(
        name='CustomHeading2',
        parent=styles['Heading2'],
        fontSize=16,
        spaceBefore=15,  # Reduced spacing
        spaceAfter=10,   # Reduced spacing
        textColor=colors.Color(0.3, 0.3, 0.3)
    ))
    styles.add(ParagraphStyle(
        name='CustomBody',
        parent=styles['Normal'],
        fontSize=11,
        leading=14,
        spaceBefore=6,   # Reduced spacing
        spaceAfter=6,    # Reduced spacing
        textColor=colors.Color(0.3, 0.3, 0.3)
    ))
    
    story = []
    
    # Title
    title = Paragraph("Python Code Analysis and Flowcharts Report", styles['CustomHeading1'])
    story.extend([
        title,
        Spacer(1, 20)  # Reduced spacing
    ])
    
    # Executive Summary
    story.append(Paragraph("Executive Summary", styles['CustomHeading2']))
    
    summary_data = [
        ['Total Elements', str(len(elements))],
        ['Total Functions/Methods', str(sum(1 for e in elements.values() if isinstance(e, FunctionInfo)) + 
                                     sum(len(e.methods) for e in elements.values() if isinstance(e, ClassInfo)))],
        ['Average Complexity', f"{sum(e.complexity for e in elements.values() if isinstance(e, FunctionInfo)) + sum(e.total_complexity for e in elements.values() if isinstance(e, ClassInfo)) / len(elements):.2f}"]
    ]
    
    summary_table = Table(summary_data, colWidths=[2*inch, 2*inch])
    summary_table.setStyle(TableStyle([
        ('GRID', (0, 0), (-1, -1), 1, colors.Color(0.8, 0.8, 0.8)),
        ('BACKGROUND', (0, 0), (0, -1), colors.Color(0.95, 0.95, 0.95)),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.Color(0.3, 0.3, 0.3)),
        ('PADDING', (0, 0), (-1, -1), 12),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
    ]))
    
    story.extend([
        summary_table,
        Spacer(1, 20)  # Reduced spacing
    ])

    # Flowcharts
    for name, item in flowcharts.items():
        if isinstance(item, dict):  # Class
            class_title = Paragraph(f"Class: {name}", styles['CustomHeading2'])
            story.append(class_title)
            
            for method_name, flowchart in item.items():
                method_title = Paragraph(f"Method: {method_name}", styles['CustomBody'])
                story.append(method_title)
                story.append(Spacer(1, 10))  # Reduced spacing
                
                png_path = os.path.join(current_dir, f"{name}_{method_name}_flowchart.png")
                safe_write_png(flowchart, png_path)
                
                img = Image(png_path, width=5.5*inch, height=3.5*inch)
                frame = KeepInFrame(6*inch, 4*inch, [img], mode='shrink')
                story.append(frame)
                story.append(Spacer(1, 15))  # Reduced spacing
        else:  # Function
            function_title = Paragraph(f"Function: {name}", styles['CustomHeading2'])
            story.append(function_title)
            story.append(Spacer(1, 10))  # Reduced spacing
            
            png_path = os.path.join(current_dir, f"{name}_flowchart.png")
            safe_write_png(item, png_path)
            
            img = Image(png_path, width=5.5*inch, height=3.5*inch)
            frame = KeepInFrame(6*inch, 4*inch, [img], mode='shrink')
            story.append(frame)
            story.append(Spacer(1, 15))  # Reduced spacing

    # Build the PDF with header and footer
    doc.build(story, onFirstPage=create_header_footer, onLaterPages=create_header_footer)

def main():
    logging.info(f"Analyzing directory: {input_dir}")
    elements = analyze_directory(input_dir)
    
    if not elements:
        logging.error("No classes or functions found in the specified directory.")
        return
    
    logging.info(f"Found {len(elements)} classes and functions.")
    flowcharts = generate_flowcharts(elements)
    
    pdf_path = os.path.join(current_dir, 'Python_Flowcharts_Report.pdf')
    generate_pdf(flowcharts, elements, pdf_path)
    logging.info(f"PDF report generated: {pdf_path}")

if __name__ == "__main__":
    main()